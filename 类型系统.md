# 类型系统

## 如何解决孤儿规则问题？

什么是孤儿规则？

要为类型 A 实现特征 T，那么 A 或者 T 必须至少有一个在当前的作用范围内。

举个例子

```rust
use std::fmt;
// 我是没有办法为Vec实现Display的，
// 这是因为破坏性，我不能给Vec私自实现trait，
// 如果别人在其他文件同时引入了Display,和Vec那他就会无意间包含我的实现。
impl fmt::Display for Vec<String> {

}
```

所以我们需要使用一个 Tulple 进行包裹

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}
```

## 什么是永不返回类型！？

! 用来说明一个函数永不返回任何值，

目前理解是一个函数出现了 panic!，则他的返回类型是！。就代表这个函数无法执行到他返回的那一步
即永无返回值

## 动态大小类型 DST(dynamically sized types)

我们先来解释一个概念，什么是 DST？
编译器无法在编译期得知该类型值的大小，只有到了程序运行时，才能动态获知。这种类型的变量就是 DST（动态大小类型）

我们来了解下他是如何使用的？

在 rust 中使用的类型都得在编译过程中确定类型。正因为编译器无法在编译期获知类型大小，若你试图在代码中直接使用 DST 类型，将无法通过编译。

那 DST 类型该怎么处理？动态类型会存放在堆内存中。在栈内存中有存在一个引用来执行该堆内存空间，rust 代码变量存放的是该引用，所以该引用的空间大小是确定的，能过符合 rust 的规则。

我们来看下面的例子

```rust
// error
// 原因：
// s1, s2占有内存是不同的，
// 依据规则 Rust 需要明确地知道一个特定类型的值占据了多少内存空间，同时该类型的所有值都必须使用相同大小的内存。
// 我们没办法用一个特定的变量类型在存放。

// 方案：
// 所以在 Rust 中 str 类型是使用引用存放在栈上的，
// &str 引用存储在栈上，具有固定大小，同时它指向的数据存储在堆中，也是已知的大小，
let s1: str = "Hello there!";
let s2: str = "How's it going?";

// ok
let s3: &str = "on?"
```

## Sized 特征

那么在使用泛型时，Rust 如何保证我们的泛型参数是固定大小的类型呢？

```rust
// 实际上编译器自动帮我们加上了 Sized 特征约束
// 保证了该泛型的变量是固定大小的类型的。
fn generic<T: Sized>(t: T) {
    // --snip--
}


// T可能是没有固定大小的类型
// 因此只能使用他的引用，即t变量的类型只能是&T,
// 这样确保了在 rust 中使用的类型都得在编译过程中确定固定大小类型。这一条规则
fn generic<T: ?Sized>(t: &T) {
    // --snip--
}

```
